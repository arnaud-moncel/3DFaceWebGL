<script id="shader-fs" type="x-shader/x-fragment">
    precision mediump float;

    varying vec2 vTextureCoord;
    varying vec3 vNormal;
    varying vec3 vMvPosition;

    //other
    uniform mat3 uNMatrix;
    uniform float indiceOfRefraction;
    uniform float roughness;
    uniform float fresnelPow;
    uniform vec3 ecPosition;
    uniform int phong;

    //texture
    uniform sampler2D diffTexture;
    uniform sampler2D redNormals;
    uniform sampler2D greenNormals;
    uniform sampler2D blueNormals;
    uniform sampler2D specNormals;
    uniform sampler2D specTexture;

    //light information
    uniform int enabledLights[8];
    uniform vec3 lightPos[8];
    uniform vec3 lightAmbient[8];
    uniform vec3 lightDiffuse[8];
    uniform vec3 lightSpecular[8];

    //material information
    uniform vec3 materialAmbient;
    uniform vec3 materialDiffuse;
    uniform vec3 materialSpecular;

    /*
    *   Function
    */
    float getPhongSpec(vec3 normal, vec3 pos, vec3 lightDir)
    {
        vec3 R = 2.0 * dot(normal, pos) * normal - pos;
        R = normalize(R);

        float alpha = dot(lightDir, R);
        alpha = max(alpha, 0.0);

        return pow(alpha, 1.0 - indiceOfRefraction);
    }

    float getCookSpec(vec3 normal, vec3 viewVec, vec3 lightDir)
    {
        float NdotL = max(dot(normal, lightDir), 0.0);

        float spec = 0.0;
        if(NdotL > 0.0)
        {
            vec3 Hv = normalize(lightDir + viewVec);
            float NdotH = max(dot(normal, Hv), 0.0);
            float NdotV = max(dot(normal, viewVec), 0.0);
            float VdotH = max(dot(viewVec, Hv), 0.0);
            float squareR = roughness * roughness;

            //geometric attenuation
            float nh2 = 2.0 * NdotH;
            float g1 = (nh2 * NdotV) / VdotH;
            float g2 = (nh2 * NdotL) / VdotH;
            float geoAtt = min(1.0, min(g2, g2));

            //beckmann distribution
            float r1 = 1.0 / (4.0 * squareR * pow(NdotH, 4.0));
            float r2 = (NdotH * NdotH - 1.0) / (squareR * NdotH * NdotH);
            float roughness = r1 * exp(r2);

            //fresnel
            float fresnel = pow(1.0 - VdotH, 5.0);
            fresnel *= 1.0 - fresnelPow;
            fresnel += fresnelPow;

            spec = (fresnel * geoAtt * roughness) / (NdotV * NdotL * 3.14);
        }

        return NdotL * (indiceOfRefraction + spec * (1.0 - indiceOfRefraction));
    }

    void main(void)
    {
        //textures variables
        vec3 textureColor = texture2D(diffTexture, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        vec3 specColor = texture2D(specTexture, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;

        //normal map
        vec3 normR = texture2D(redNormals, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        normR  = normR * 2.0 - 1.0;
        normR = uNMatrix * normR;
        normR = normalize(normR);

        vec3 normG = texture2D(greenNormals, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        normG  = normG * 2.0 - 1.0;
        normG = uNMatrix * normG;
        normG = normalize(normG);

        vec3 normB = texture2D(blueNormals, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        normB  = normB * 2.0 - 1.0;
        normB = uNMatrix * normB;
        normB = normalize(normB);

        vec3 normS = texture2D(specNormals, vec2(vTextureCoord.s, vTextureCoord.t)).rgb;
        normS  = normS * 2.0 - 1.0;
        normS = uNMatrix * normS;
        normS = normalize(normS);

        //normal variable
        vec3 norm = normalize(uNMatrix * vNormal);

        vec3 viewVec = normalize(-ecPosition);

        float Ka = 0.5;
        float Kd = 2.5;
        float Ks = 0.8;

        //variablesforphong
        vec3 position = normalize(-vMvPosition);

        vec3 Ia = vec3(0.0, 0.0, 0.0);
        vec3 Id = vec3(0.0, 0.0, 0.0);
        vec3 Is = vec3(0.0, 0.0, 0.0);

        float nbLight = 0.0;

        //for each light
        for(int i=0; i<8; i++)
        {
            if(enabledLights[i] == 1)
            {
                //ambient
                Ia += lightAmbient[i] * materialAmbient * Ka;

                //diffuse
                vec3 L = lightPos[i] - vMvPosition;
                L = normalize(L);

                float theta = dot(L, norm);
                theta = max(theta, 0.0);

                float thetaR = dot(L, normR);
                thetaR = max(thetaR, 0.0);

                float thetaG = dot(L, normG);
                thetaG = max(thetaG, 0.0);

                float thetaB = dot(L, normB);
                thetaB = max(thetaB, 0.0);

                Id += lightDiffuse[i] * textureColor * materialDiffuse * Kd * vec3(thetaR, thetaG, thetaB);// * theta;

                //specular
                float spec;
                spec = phong == 1 ? getPhongSpec(normS, position, L) : getCookSpec(normS, viewVec, L);

                Is += lightSpecular[i] * specColor * materialSpecular * spec * Ks;

                nbLight++;
            }
        }

        Ia /= nbLight;

        vec3 I = Ia + Id + Is;

        gl_FragColor = vec4(I, 1.0);
    }
</script>