<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
	    precision mediump float;
	#endif

    uniform mat3 uNMatrix;

    //textures
    uniform sampler2D diffTexture;
    uniform sampler2D redNormals;
    uniform sampler2D greenNormals;
    uniform sampler2D blueNormals;
    uniform sampler2D specNormals;
    uniform sampler2D specTexture;

    //other information
    uniform float roughness;
    uniform float indiceOfRefraction;
    uniform vec3 ecPosition;

    //light information
    uniform int enabledLights[8];
    uniform vec3 lightPos[8];
    uniform vec3 lightDirection[8];
    uniform vec3 lightAmbient[8];
    uniform vec3 lightDiffuse[8];
    uniform vec3 lightSpecular[8];
    uniform float lightCutoff[8];

    //material information
    uniform vec3 materialAmbient;
    uniform vec3 materialDiffuse;
    uniform vec3 materialSpecular;

    uniform int phong;

    //varying variables for vs
    varying vec2 vTextureCoord;
    varying vec3 vNormal;

    varying vec3 vPosition;

    float beckmann(	float cosalpha, float r )
    {
        float res = 0.0;

        float m2 = r*r;
        float c2 = cosalpha*cosalpha;

        res = (exp( (c2-1.0) / (c2*m2))) / (c2*c2*m2);

        return res;
    }

    float fresnelReflectance( float VdotH, float f )
    {
        float base = 1.0-VdotH;
        float exponential = pow(base, 5.0);
        return min(1.0,(exponential + f * (1.0 - exponential)));
    }


    float geomasking( float cos_theta_r, float cos_alpha, float cos_theta_i, float cos_beta )
    {
        float res = 0.0;

        float shadowing = (cos_alpha * cos_theta_r) / cos_beta;
        float masking = (cos_alpha * cos_theta_i) / cos_beta;
        res = min(1.0, 2.0 * min( shadowing, masking));

        return res;
    }

    float geomasking2( float LdotN, float VdotN, float VdotH, float HdotN)
    {
        // VdotH should never be zero. Only possible if
        // L and V end up in the same plane (unlikely).
        float denom = max( VdotH, 1.192092896e-07 );

        float numL = min(VdotN, LdotN);
        float numR = 2.0*HdotN;
        if((numL*numR) <= denom )
        {
            //numL = numL == VdotN ? 1.0 : (LdotN / VdotN);	// VdotN is > 0 if this division is used
            //return (numL*numR) / denom;
            return 1.0;
        }
        else
            return 1.0 / VdotN;
    }


    //param lightPos, viewVec , normal, colorNorm
    float diffuse( vec3 Lp, vec3 Vv, vec3 N, vec3 ScannedNormal)
    {
        float ns_dot_v = dot(N,Vv);
        float ns_dot_map = dot(N,ScannedNormal);
        float map_dot_v = dot(ScannedNormal,Vv);

        //float cos_theta_i = ( map_dot_v <= 0.0 && ns_dot_v >= 0.0) ? 0.0 : dot(Ln, ScannedNormal) ;
        //float cos_theta_i = ( ns_dot_map <= 0.0 && ns_dot_v >= 0.0) ? dot(Ln, Ns) : dot(Ln, ScannedNormal) ;
        float cos_theta_i = dot(Lp,ScannedNormal);

        return  cos_theta_i;
    }

    float specular( vec3 Ln, vec3 Vf, vec3 Ns, vec3 ScannedNormal, float r, float ior)
    {
        float spec = 0.0;

        float cos_theta_i = 0.0;
        float cos_theta_r = 0.0;
        float cos_alpha = 0.0;
        float cos_beta = 0.0;
        float alpha = 0.0;
        float D = 0.0;
        float G = 0.0;
        float F = 0.0;

        vec3 Hn = normalize(Ln+Vf);
        float ns_dot_v = dot(Ns,Vf);
        float ns_dot_map = dot(Ns,ScannedNormal);

        // check orientation, use Ns if needed
        if (ns_dot_map <= 0.0 && ns_dot_v >= 0.0)
        {
            cos_theta_r = ns_dot_v;
            cos_theta_i = dot(Ln,Ns);
            cos_alpha = dot(Hn,Ns);
        }
        else
        {
            cos_theta_r = max( 0.00001, dot(Vf,ScannedNormal) );
            cos_theta_i = dot(Ln,ScannedNormal);
            cos_alpha = dot(Hn,ScannedNormal);
        }

        cos_beta = dot(Vf,Hn);

        D = beckmann( cos_alpha, r );
        G = geomasking( cos_theta_r, cos_alpha, cos_theta_i, cos_beta );
        F = fresnelReflectance( cos_beta, ior );

        spec = (F/3.14)*(D/cos_theta_i)*(G/cos_theta_r);

        return spec;
    }

    //for phong
    vec3 getSpecular(vec3 normal, vec3 lightDir, vec3 viewDir, float specPow, vec3 col)
    {
       // vec3 transformedNormal =normalize(uNMatrix * normal);
        vec3 reflectDir = normalize(reflect(-lightDir, normal));
        float specAngle = max(dot(reflectDir, viewDir), 0.0); //max(dot(transformedNormal.xyz, lightDir), 0.0);//
        float specular = pow(specAngle, specPow);
        return vec3(specular);//*col;
    }

    void main(void)
    {
        vec3 snorm = texture2D(specNormals, vTextureCoord.st).rgb;
        snorm  = snorm * 2.0 - 1.0;
        snorm = uNMatrix * snorm;
        snorm = normalize(snorm);

        vec3 rnorm = texture2D(redNormals, vTextureCoord.st).rgb;
        rnorm  = rnorm * 2.0 - 1.0;
        rnorm = uNMatrix * rnorm;
        rnorm = normalize(rnorm);

        vec3 gnorm = texture2D(greenNormals, vTextureCoord.st).rgb;
        gnorm  = gnorm * 2.0 - 1.0;
        gnorm = uNMatrix * gnorm;
        gnorm = normalize(gnorm);

        vec3 bnorm = texture2D(blueNormals, vTextureCoord.st).rgb;
        bnorm  = bnorm * 2.0 - 1.0;
        bnorm = uNMatrix * bnorm;
        bnorm = normalize(bnorm);

        vec3  texColor =  texture2D(diffTexture, vTextureCoord.st).rgb;
        texColor = pow(texColor,vec3(2.2));
        vec3  specTexColor = texture2D(specTexture, vTextureCoord.st).rgb;
        specTexColor = pow(specTexColor,vec3(2.2));


        vec3 LightIntensity;
        //vec3 reflectVec[8];
        float spec[8];
        vec3 diffuseCol[8];
        vec3 viewVec = normalize(-ecPosition);

        vec3 specComponent = vec3(0,0,0) ;
        vec3 diffComponent = vec3(0,0,0) ;
        vec3 ambComponent = vec3(0,0,0);

        float nbLights = 0.0;
        for(int i = 0; i < 7; i++)
        {
            if( enabledLights[i] == 1)
            {
                if(phong == 1)
                {
                    vec3 spec = getSpecular(snorm, normalize(lightDirection[i]), viewVec, 10.0, specTexColor.rgb);
                    specComponent += spec * lightSpecular[i] * materialSpecular;
                }
                else
                {
                   // vec3 transformedSnorm =normalize(uNMatrix * snorm);
                    vec3 transformedVnorm =normalize(uNMatrix * vNormal);
                    spec[i] = specular(normalize(-lightDirection[i]), viewVec, transformedVnorm, snorm, roughness, indiceOfRefraction);

                    specComponent += spec[i] * lightSpecular[i] * materialSpecular * specTexColor.rgb;
                }

                diffuseCol[i].r = diffuse(lightPos[i], viewVec , normalize(vNormal), rnorm);//min(max(dot(-lightPos[i], rnorm), 0.0),1.0);
                diffuseCol[i].g = diffuse(lightPos[i], viewVec , normalize(vNormal), gnorm);//min(max(dot(-lightPos[i], gnorm), 0.0),1.0);
                diffuseCol[i].b = diffuse(lightPos[i], viewVec , normalize(vNormal), bnorm);//min(max(dot(-lightPos[i], bnorm), 0.0),1.0);

                diffComponent +=  diffuseCol[i].rgb * lightDiffuse[i] * materialDiffuse * texColor.rgb;
                ambComponent += lightAmbient[i] * materialAmbient;

                nbLights++;
            }
        }

        specComponent /= nbLights;
        diffComponent /= nbLights;
        ambComponent /= nbLights;

        //The scanning light
        //const int i = 0;

        nbLights = 0.0;
        for(int i = 0; i < 7; i++)
        {
            float spotDot = dot(-lightPos[i],normalize(lightDirection[i]));
            float cosDot = acos(spotDot);
            float spotCutoff = lightCutoff[i];
            if(cosDot < spotCutoff && enabledLights[i] == 1)
            {
                if(phong == 1)
                {
                    specComponent += getSpecular(snorm, normalize(lightDirection[i]), viewVec, 10.0, lightSpecular[i] * specTexColor.rgb);
                }
                else
                {
                    spec[i] = specular(lightPos[i], viewVec, normalize(vNormal), snorm, roughness, indiceOfRefraction);

                    specComponent += spec[i] * lightSpecular[i] * materialSpecular * specTexColor.rgb;
                }

                diffuseCol[i].r = max(dot(-lightPos[i], rnorm), 0.0);
                diffuseCol[i].g = max(dot(-lightPos[i], gnorm), 0.0);
                diffuseCol[i].b = max(dot(-lightPos[i], bnorm), 0.0);

                diffComponent += diffuseCol[i].rgb * lightDiffuse[i] * materialDiffuse * texColor.rgb;
                ambComponent += lightAmbient[i] * materialAmbient;

                nbLights++;
            }
        }

        specComponent /= nbLights;
        diffComponent /= nbLights;
        ambComponent /= nbLights;

        LightIntensity =  0.5*diffComponent + 0.5*specComponent + ambComponent;

        LightIntensity = pow(LightIntensity, vec3(1.0/2.2));

        gl_FragColor = vec4 (LightIntensity, 1.0);
    }
</script>