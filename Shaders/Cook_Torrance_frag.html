<script id="shader-fs" type="x-shader/x-fragment">
    #ifdef GL_ES
	    precision mediump float;
	#endif

    uniform mat3 uNMatrix;

    //textures
    uniform sampler2D diffTexture;
    uniform sampler2D redNormals;
    uniform sampler2D greenNormals;
    uniform sampler2D blueNormals;
    uniform sampler2D specNormals;
    uniform sampler2D specTexture;

    //other information
    uniform float roughness;
    uniform float indiceOfRefraction;
    uniform vec3 ecPosition;

    //light information
    uniform int enabledLights[8];
    uniform vec3 lightPos[8];
    uniform vec3 lightDirection[8];
    uniform vec3 lightAmbient[8];
    uniform vec3 lightDiffuse[8];
    uniform vec3 lightSpecular[8];
    uniform float lightCutoff[8];

    //material information
    uniform vec3 materialAmbient;
    uniform vec3 materialDiffuse;
    uniform vec3 materialSpecular;

    //varying variables for vs
    varying vec2 vTextureCoord;
    varying vec3 normal;

    varying vec4 position;

    float beckmann(	float cosalpha, float r )
    {
        float res = 0.0;

        float m2 = r*r;
        float c2 = cosalpha*cosalpha;

        res = (exp( (c2-1.0) / (c2*m2))) / ( c2*c2*m2);

        return res;
    }

    float fresnelReflectance( float VdotH, float f )
    {
        float base = 1.0-VdotH;
        float exponential = pow(base, 5.0);
        return min(1.0,(exponential + f * (1.0 - exponential)));
    }


    float geomasking( float cos_theta_r, float cos_alpha, float cos_theta_i, float cos_beta )
    {
        float res = 0.0;

        float shadowing = (cos_alpha * cos_theta_r) / cos_beta;
        float masking = (cos_alpha * cos_theta_i) / cos_beta;
        res = min(1.0, 2.0 * min( shadowing, masking));

        return res;
    }

    float geomasking2( float LdotN, float VdotN, float VdotH, float HdotN)
    {
        // VdotH should never be zero. Only possible if
        // L and V end up in the same plane (unlikely).
        float denom = max( VdotH, 1.192092896e-07 );

        float numL = min(VdotN, LdotN);
        float numR = 2.0*HdotN;
        if((numL*numR) <= denom )
        {
            //numL = numL == VdotN ? 1.0 : (LdotN / VdotN);	// VdotN is > 0 if this division is used
            //return (numL*numR) / denom;
            return 1.0;
        }
        else
            return 1.0 / VdotN;
    }


    float diffuse( vec3 Ln, vec3 Vf, vec3 Ns, vec3 ScannedNormal)
    {
        float ns_dot_v = dot(Ns,Vf);
        float ns_dot_map = dot(Ns,ScannedNormal);
        float map_dot_v = dot(ScannedNormal,Vf);

        //float cos_theta_i = ( map_dot_v <= 0.0 && ns_dot_v >= 0.0) ? 0.0 : dot(Ln, ScannedNormal) ;
        //float cos_theta_i = ( ns_dot_map <= 0.0 && ns_dot_v >= 0.0) ? dot(Ln, Ns) : dot(Ln, ScannedNormal) ;
        float cos_theta_i = dot(Ln,ScannedNormal);
        return  cos_theta_i;
    }

    float specular( vec3 Ln, vec3 Vf, vec3 Ns, vec3 ScannedNormal, float r, float ior)
    {
        float spec = 0.0;

        float cos_theta_i = 0.0;
        float cos_theta_r = 0.0;
        float cos_alpha = 0.0;
        float cos_beta = 0.0;
        float alpha = 0.0;
        float D = 0.0;
        float G = 0.0;
        float F = 0.0;

        vec3 Hn = normalize(Ln+Vf);
        float ns_dot_v = dot(Ns,Vf);
        float ns_dot_map = dot(Ns,ScannedNormal);

        // check orientation, use Ns if needed
        if (ns_dot_map <= 0.0 && ns_dot_v >= 0.0)
        {
            cos_theta_r = ns_dot_v;
            cos_theta_i = dot(Ln,Ns);
            cos_alpha = dot(Hn,Ns);
        }
        else
        {
            cos_theta_r = max( 0.00001, dot(Vf,ScannedNormal) );
            cos_theta_i = dot(Ln,ScannedNormal);
            cos_alpha = dot(Hn,ScannedNormal);
        }

        cos_beta = dot(Vf,Hn);

        D = beckmann( cos_alpha, r );
        G = geomasking( cos_theta_r, cos_alpha, cos_theta_i, cos_beta );
        F = fresnelReflectance( cos_beta, ior );

        spec = (F/3.14)*(D/cos_theta_i)*(G/cos_theta_r);

        return spec;
    }

    void main(void)
    {
        vec3 snorm = texture2D(specNormals, vTextureCoord.st).rgb;
        snorm  = snorm * 2.0 - 1.0;
        snorm = uNMatrix * snorm;
        snorm = normalize(snorm);

        vec3 rnorm = texture2D(redNormals, vTextureCoord.st).rgb;
        rnorm  = rnorm * 2.0 - 1.0;
        rnorm = uNMatrix * rnorm;
        rnorm = normalize(rnorm);

        vec3 gnorm = texture2D(greenNormals, vTextureCoord.st).rgb;
        gnorm  = gnorm * 2.0 - 1.0;
        gnorm = uNMatrix * gnorm;
        gnorm = normalize(gnorm);

        vec3 bnorm = texture2D(blueNormals, vTextureCoord.st).rgb;
        //bnorm  = bnorm * 2.0 - 1.0;
        bnorm = uNMatrix * bnorm;
        bnorm = normalize(bnorm);

        vec3  texColor =  texture2D(diffTexture, vTextureCoord.st).rgb;
        texColor = pow(texColor,vec3(2.2));
        vec3  specTexColor = texture2D(specTexture, vTextureCoord.st).rgb;
        specTexColor = pow(specTexColor,vec3(2.2));


        vec3 LightIntensity;
        vec3 reflectVec[8];
        float spec[8];
        vec3 diffuseCol[8];
        vec3 viewVec = normalize(-ecPosition);

        vec3 specComponent = vec3(0,0,0) ;
        vec3 diffComponent = vec3(0,0,0) ;
        vec3 ambComponent = vec3(0,0,0);

        float nbLights = 0.0;
        for(int i = 0; i < 7; i++)
        {
            if( enabledLights[i] == 1)
            {
                spec[i]=specular(lightPos[i], viewVec, normal , snorm, roughness, indiceOfRefraction);

                diffuseCol[i].r   = diffuse(lightPos[i], viewVec , normal, rnorm);//min(max(dot(-lightPos[i], rnorm), 0.0),1.0);
                diffuseCol[i].g   = diffuse(lightPos[i], viewVec , normal, gnorm);//min(max(dot(-lightPos[i], gnorm), 0.0),1.0);
                diffuseCol[i].b   = diffuse(lightPos[i], viewVec , normal, bnorm);//min(max(dot(-lightPos[i], bnorm), 0.0),1.0);

                specComponent += spec[i] * lightSpecular[i] * materialSpecular * specTexColor.rgb;
                diffComponent +=  diffuseCol[i].rgb * lightDiffuse[i] * materialDiffuse * texColor.rgb;
                ambComponent += lightAmbient[i] * materialAmbient * texColor.rgb;

                nbLights++;
            }
        }

        const int i = 0;
        specComponent /= nbLights;
        diffComponent /= nbLights;
        specComponent /= nbLights;

        //The scanning light

        float spotDot = dot(-lightPos[i],normalize(lightDirection[i]));
        float cosDot = acos(spotDot);
        float spotCutoff = lightCutoff[i];
        if(cosDot < spotCutoff && enabledLights[i] == 1)
        {
            spec[i] = specular(lightPos[i], viewVec, normal , snorm, roughness, indiceOfRefraction);

            diffuseCol[i].r   = max(dot(-lightPos[i], rnorm), 0.0);
            diffuseCol[i].g   = max(dot(-lightPos[i], gnorm), 0.0);
            diffuseCol[i].b   = max(dot(-lightPos[i], bnorm), 0.0);

            specComponent += spec[i] * lightSpecular[i] * lightSpecular[i] * specTexColor.rgb;
            diffComponent += diffuseCol[i].rgb * lightDiffuse[i] * materialDiffuse * texColor.rgb;
            ambComponent += lightAmbient[i] * materialAmbient;
        }

        LightIntensity =  0.5*diffComponent + 0.5*specComponent + ambComponent;

        LightIntensity = pow(LightIntensity, vec3(1.0/2.2));

        gl_FragColor = vec4 (LightIntensity, 1.0);
    }
</script>